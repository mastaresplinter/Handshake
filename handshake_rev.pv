type key.

fun senc(bitstring, key): bitstring.

reduc forall m: bitstring, k: key; sdec(senc(m, k), k) = m.

type skey.
type pkey.
type nonce.

fun pk(skey): pkey.
fun aenc(bitstring, pkey): bitstring.

reduc forall m: bitstring, k: skey; adec(aenc(m, pk(k)), k) = m.

type sskey.
type spkey.

fun spk(sskey): spkey.
fun sign(bitstring, sskey): bitstring.

reduc forall m: bitstring, k: sskey; getmess(sign(m, k)) = m.
reduc forall m: bitstring, k: sskey; checksign(sign(m, k), spk(k)) = m.

free c: channel.
free s: bitstring [ private ].

event aliceReceiveKey(key).
event bobFreshKey(key).

query attacker(s).

query x: key; inj-event(aliceReceiveKey(x)) ==> inj-event(bobFreshKey(x)).

(* The above does not hold for injective version inj-event, meaning
   that the replay attack on Alice is possible. Fix the protocol so that the
   above query verifies also with inj-event as specified above. *)

let alice(pkA: pkey, skA: skey, pkB: spkey) =
  new Na : nonce;																		(* Generate new nonce *)
  out(c, Na);																			(* Send nonce in public *)
  out(c, pkA);
  in(c, x: bitstring);
  let sigB = adec(x, skA) in

  let (=pkA, =pkB, =Na, k: key) = checksign(sigB, pkB) in	(* This statement checks that sigB is a signature under pkB where the
															   first element is Alices public key, second is bobs public key,
															   third is the nonce Na generated by alice, and fourth is a symmetric
															   key k *)															   
  event aliceReceiveKey(k);
  out(c, senc(s, k)).

let bob(pkB: spkey, skB: sskey) =
  in(c, NX: nonce);																		(* bob receives nonce *)
  in(c, pkX: pkey);
  new k: key;
  event bobFreshKey(k);
  out(c, aenc(sign((pkX, pkB, NX, k), skB), pkX));										(* Add the nonce received from Alice to the signature of bob*)
  in(c, x:bitstring);
  let z = sdec(x, k) in 0.

process
  new skA: skey; new skB: sskey;
  let pkA = pk(skA) in out(c, pkA);
  let pkB = spk(skB) in out(c, pkB);
  ( (!alice(pkA, skA, pkB)) | (!bob(pkB, skB)) )